# 1.十大排序算法

| 排序算法 |  平均时间复杂度  | 最好情况 |     最坏情况     | 空间复杂度 | 排序方式 | 稳定性 |
| :------: | :--------------: | :------: | :--------------: | :--------: | :------: | :----: |
| 冒泡排序 | O(N<sup>2</sup>) |   O(N)   | O(N<sup>2</sup>) |    O(1)    | 内部排序 |  稳定  |
|          |                  |          |                  |            |          |        |
|          |                  |          |                  |            |          |        |
|          |                  |          |                  |            |          |        |
|          |                  |          |                  |            |          |        |
|          |                  |          |                  |            |          |        |
|          |                  |          |                  |            |          |        |
|          |                  |          |                  |            |          |        |
|          |                  |          |                  |            |          |        |
|          |                  |          |                  |            |          |        |



## 1.冒泡排序

### 1.原版

```java
public static void main(String[] args) {
    int[] array = new int[]{5,8,6,3,4,9,2,1,7};
    sort(array);
    System.out.println(Arrays.toString(array));
}

public static void sort(int[] array){
    int length = array.length;
    for(int i = 0; i < length - 1; i++){
        for(int j = 0; j < length - i - 1; j++){
            //升序
            if(array[j] > array[j+1]){
                swap(array, j, j + 1);
            }
        }
    }
}

public static void swap(int[] array, int i, int j){
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
```

### 2.改进版1——当数组有序后不再进行剩下的排序

```java
public static void main(String[] args) {
    int[] array = new int[]{5,8,6,3,4,9,2,1,7};
    sort(array);
    System.out.println(Arrays.toString(array));
}

public static void sort(int[] array){
    //有序标记，每一轮的初始值都是true
    int length = array.length;
    for(int i = 0; i < length - 1; i++){
        boolean isSorted = true;
        for(int j = 0; j < length - i - 1; j++){
            //升序
            if(array[j] > array[j+1]){
                swap(array, j, j + 1);
                //因为有元素进行交换，所以不是有序的，标记变为false
                isSorted = false;
            }
        }
        //如果没有匀速进行交换，则说明数组已经有序，跳出循环
        if(isSorted){
            break;
        }
    }
}

public static void swap(int[] array, int i, int j){
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
```

### 3.改进版2——避免有序区的重复比较

```java
public static void main(String[] args) {
    int[] array = new int[]{3,4,2,1,5,6,7,8};
    sort(array);
    System.out.println(Arrays.toString(array));
}

public static void sort(int[] array){
    //有序标记，每一轮的初始值都是true
    int length = array.length;
    //无序数列的边界，每次比较只需要比到这里为止
    int sortedBorder = length - 1;
    //记录最后一次交换的位置
    int lastExchangeIndex = 0;

    for(int i = 0; i < length - 1; i++){
        boolean isSorted = true;
        for(int j = 0; j < sortedBorder; j++){
            //升序
            if(array[j] > array[j+1]){
                swap(array, j, j + 1);
                //因为有元素进行交换，所以不是有序的，标记变为false
                isSorted = false;
                //更新为最后一次交换元素的位置
                lastExchangeIndex = j;
            }
        }
        //更新有序区的边界
        sortedBorder = lastExchangeIndex;
        //如果没有匀速进行交换，则说明数组已经有序，跳出循环
        if(isSorted){
            break;
        }
    }
}

public static void swap(int[] array, int i, int j){
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
```